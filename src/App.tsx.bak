import React, { useEffect, useMemo, useRef, useState } from 'react'
import { useQuery, useQueryClient } from '@tanstack/react-query'
import { api } from './lib/api'
import type { Job, Progress } from './lib/api'
import {
  Pause, Play, FileDown, XCircle, Trash2, ChevronsUp, MoreVertical, Check, X, Info
} from 'lucide-react'
import ThemeToggle from './components/ThemeToggle'
import clsx from 'clsx'
import { DndContext, closestCenter, PointerSensor, useSensor, useSensors } from '@dnd-kit/core'
import { arrayMove, SortableContext, useSortable, verticalListSortingStrategy } from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'

/* ----------------------------- Helpers/Types ----------------------------- */

type ValidateSummary = {
  sizeBytes: number
  total: number
  valid: number
  invalid: number
  invalidSamples: string[]
  uniqueRefKeys: string[]
}
type InsertWhere = { mode: 'top'|'bottom'|'index'; index?: number }
const STATUS_LIST = ['queued','running','pausing','paused','completed','failed','canceled'] as const
type StatusKey = typeof STATUS_LIST[number]

const LS_OWNERS = 'ownerFilter'
const LS_STATUSES = 'statusFilter'
const LS_MAP_HISTORY = 'mapping_history_v1'
const LS_PAGE_SIZE = 'jobsPageSize'

/* ---------------------------- Toasts (simple) ---------------------------- */

type Toast = { id: string; type: 'success'|'error'|'info'; title: string; detail?: string }
const Toasts: React.FC<{toasts: Toast[], onDismiss:(id:string)=>void}> = ({toasts, onDismiss}) => (
  <div className="fixed top-3 right-3 z-50 space-y-2">
    {toasts.map(t => (
      <div key={t.id}
           className={clsx("min-w-[260px] max-w-[420px] rounded-lg border shadow-soft px-3 py-2 text-sm",
             t.type==='success' && "bg-emerald-50 border-emerald-200 text-emerald-900 dark:bg-emerald-950/40 dark:border-emerald-900 dark:text-emerald-100",
             t.type==='error' && "bg-rose-50 border-rose-200 text-rose-900 dark:bg-rose-950/40 dark:border-rose-900 dark:text-rose-100",
             t.type==='info' && "bg-slate-50 border-slate-200 text-slate-900 dark:bg-slate-900/60 dark:border-slate-800 dark:text-slate-100",
           )}>
        <div className="flex items-start gap-2">
          <div className="mt-0.5">
            {t.type==='success' ? <Check size={16}/> : t.type==='error' ? <X size={16}/> : <Info size={16}/>}
          </div>
          <div className="flex-1">
            <div className="font-medium">{t.title}</div>
            {!!t.detail && <div className="text-xs opacity-80 whitespace-pre-wrap">{t.detail}</div>}
          </div>
          <button className="text-xs underline opacity-70 hover:opacity-100" onClick={()=>onDismiss(t.id)}>Dismiss</button>
        </div>
      </div>
    ))}
  </div>
)

/* ----------------------------- Data Fetching ----------------------------- */

function useJobs() {
  return useQuery({
    queryKey: ['jobs'],
    queryFn: () => api.listJobs(false, ''),
    refetchInterval: 5000
  })
}

/* ---------------------------------- App --------------------------------- */

export default function App() {
  const qc = useQueryClient()
  const {data: jobs = [], isFetching} = useJobs()

  // Filters (persisted)
  const [ownerFilter, setOwnerFilter] = useState<string[]>([])
  const [statusFilter, setStatusFilter] = useState<StatusKey[]>([])
  // Free search (not persisted)
  const [q, setQ] = useState('')

  // restore filters on mount
  useEffect(() => {
    try {
      const o = JSON.parse(localStorage.getItem(LS_OWNERS) || '[]')
      const s = JSON.parse(localStorage.getItem(LS_STATUSES) || '[]')
      setOwnerFilter(Array.isArray(o) ? o : [])
      setStatusFilter(Array.isArray(s) ? s : [])
    } catch {}
  }, [])
  // persist on change
  useEffect(() => { try { localStorage.setItem(LS_OWNERS, JSON.stringify(ownerFilter)) } catch {} }, [ownerFilter])
  useEffect(() => { try { localStorage.setItem(LS_STATUSES, JSON.stringify(statusFilter)) } catch {} }, [statusFilter])

  // Toasts
  const [toasts, setToasts] = useState<Toast[]>([])
  const pushToast = (t: Omit<Toast,'id'>) => {
    const id = `${Date.now()}_${Math.random().toString(36).slice(2)}`
    const toast: Toast = { id, ...t }
    setToasts(prev => [...prev, toast])
    setTimeout(() => setToasts(prev => prev.filter(x => x.id !== id)), 4500)
  }

  // Announcements (none right now)
  const [announcement] = useState<string | null>(null)

  return (
    <div className="min-h-screen bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-slate-100">
      <Toasts toasts={toasts} onDismiss={(id)=>setToasts(t=>t.filter(x=>x.id!==id))} />

      {/* Top bar */}
      <div className="sticky top-0 z-10 backdrop-blur bg-white/70 dark:bg-slate-950/70 border-b border-slate-200/60 dark:border-slate-800">
        <div className="container flex items-center justify-between py-3">
          <div className="flex items-center gap-2">
            <img src="/favicon.svg" className="h-6 w-6" />
            <div className="font-semibold">JSONB Tasks</div>
          </div>

          <div className="flex-1 flex justify-center">
            {announcement && (
              <div className="px-3 py-1 rounded-md border bg-slate-100 dark:bg-slate-900 border-slate-300 dark:border-slate-700 text-sm">
                {announcement}
              </div>
            )}
          </div>

          <div className="flex items-center gap-2">
            <ThemeToggle />
          </div>
        </div>
      </div>

      <div className="container py-6 space-y-6">
        <UploadCard
          existingNames={useMemo(()=>new Set(jobs.map(j=>j.name.trim().toLowerCase())),[jobs])}
          onUploaded={async ({ job_id, insertWhere }) => {
            pushToast({type:'success', title:'Task created'})
            await qc.invalidateQueries({queryKey:['jobs']})
            if (insertWhere && job_id) {
              const all = (await qc.getQueryData<Job[]>(['jobs'])) || []
              const currentOrder = all.map(j => j.id)
              let nextOrder = currentOrder.slice()
              const idx = nextOrder.indexOf(job_id)
              if (idx !== -1) {
                nextOrder.splice(idx, 1)
                if (insertWhere.mode === 'top') nextOrder.unshift(job_id)
                else if (insertWhere.mode === 'bottom') nextOrder.push(job_id)
                else {
                  const pos = Math.max(0, Math.min((insertWhere.index || 1)-1, nextOrder.length))
                  nextOrder.splice(pos, 0, job_id)
                }
                try {
                  await api.reorder(nextOrder)
                  pushToast({type:'success', title:'Order saved'})
                } catch (e:any) {
                  pushToast({type:'error', title:'Failed to save order', detail:String(e?.message || e)})
                }
                await qc.invalidateQueries({queryKey:['jobs']})
              }
            }
          }}
          pushToast={pushToast}
        />

        {/* Queue */}
        <QueueTable
          jobs={jobs}
          isFetching={isFetching}
          q={q} setQ={setQ}
          ownerFilter={ownerFilter}
          setOwnerFilter={setOwnerFilter}
          statusFilter={statusFilter}
          setStatusFilter={setStatusFilter}
          pushToast={pushToast}
          onReorder={async (ids)=> {
            try { await api.reorder(ids); pushToast({type:'success', title:'Order saved'}) }
            catch(e:any){ pushToast({type:'error', title:'Failed to save order', detail:String(e?.message || e)}) }
            await qc.invalidateQueries({queryKey:['jobs']})
          }}
          onPause={async (id)=> {
            try { await api.pause(id); pushToast({type:'success', title:'Paused'}) }
            catch(e:any){ pushToast({type:'error', title:'Pause failed', detail:String(e?.message || e)}) }
            await qc.invalidateQueries({queryKey:['jobs']})
          }}
          onResume={async (id)=> {
            try { await api.resume(id); pushToast({type:'success', title:'Resumed'}) }
            catch(e:any){ pushToast({type:'error', title:'Resume failed', detail:String(e?.message || e)}) }
            await qc.invalidateQueries({queryKey:['jobs']})
          }}
          onExport={async (id)=> {
            try {
              const {export_id} = await api.export(id)
              pushToast({type:'info', title:'Export started'})
              const timer = setInterval(async () => {
                try {
                  const st = await api.exportStatus(export_id)
                  if (st.status === 'ready') {
                    clearInterval(timer)
                    pushToast({type:'success', title:'Export ready'})
                    window.location.href = api.exportDownloadUrl(export_id)
                  } else if (st.status === 'failed' || st.status === 'expired') {
                    clearInterval(timer)
                    pushToast({type:'error', title:`Export ${st.status}`})
                  }
                } catch (e:any) {
                  clearInterval(timer)
                  pushToast({type:'error', title:'Export failed', detail:String(e?.message || e)})
                }
              }, 3000)
            } catch (e:any) {
              pushToast({type:'error', title:'Export failed to start', detail:String(e?.message || e)})
            }
          }}
          onCancel={async (id)=> {
            try { await api.cancel(id); pushToast({type:'success', title:'Canceled'}) }
            catch(e:any){ pushToast({type:'error', title:'Cancel failed', detail:String(e?.message || e)}) }
            await qc.invalidateQueries({queryKey:['jobs']})
          }}
          onDelete={async (id)=> {
            try { await api.delete(id); pushToast({type:'success', title:'Deleted'}) }
            catch(e:any){ pushToast({type:'error', title:'Delete failed', detail:String(e?.message || e)}) }
            await qc.invalidateQueries({queryKey:['jobs']})
          }}
        />
      </div>
    </div>
  )
}

/* ------------------------------- UploadCard ------------------------------ */

function UploadCard({
  onUploaded,
  existingNames,
  pushToast,
}:{
  onUploaded:(r:{job_id?:string; insertWhere?:InsertWhere})=>void
  existingNames: Set<string>
  pushToast: (t: Omit<Toast,'id'>) => void
}) {
  const [name, setName] = useState('')
  const [prompt, setPrompt] = useState('')
  const [validate, setValidate] = useState(false)
  const [file, setFile] = useState<File|null>(null)

  const [insertMode, setInsertMode] = useState<'top'|'bottom'|'index'>('top')
  const [insertIndex, setInsertIndex] = useState<number>(1)

  const [busy, setBusy] = useState(false)
  const [summary, setSummary] = useState<ValidateSummary|null>(null)
  const [mapping, setMapping] = useState<Record<string,string>>({})

  const nameTaken = useMemo(() => {
    const n = name.trim().toLowerCase()
    return !!n && existingNames.has(n)
  }, [name, existingNames])

  const canUpload =
    !!name &&
    !nameTaken &&
    !!file &&
    !!summary &&
    summary.valid > 0 &&
    summary.invalid === 0 &&
    !busy

  // mapping history helpers
  const loadHistory = (): Record<string,string> => {
    try { return JSON.parse(localStorage.getItem(LS_MAP_HISTORY) || '{}') } catch { return {} }
  }
  const saveHistory = (next: Record<string,string>) => {
    try { localStorage.setItem(LS_MAP_HISTORY, JSON.stringify(next)) } catch {}
  }

  // Validate file + build mapping preview (remember: targetName || targetHomepage)
  useEffect(() => {
    if (!file) { setSummary(null); setMapping({}); return; }

    (async () => {
      try {
        const text = await file.text()
        const lines: any[] = []
        let parsed: any = null
        // Try JSONL first
        const nonEmpty = text.split(/\r?\n/).filter(l => l.trim().length>0)
        let jsonlOk = true
        for (const l of nonEmpty) {
          try { parsed = JSON.parse(l) } catch { jsonlOk = false; break }
          lines.push(parsed)
        }
        if (!jsonlOk) {
          const obj = JSON.parse(text)
          if (Array.isArray(obj)) lines.push(...obj)
          else lines.push(obj)
        }

        let valid = 0, invalid = 0
        const invalidSamples: string[] = []
        const keySet = new Set<string>()
        for (const o of lines) {
          const ref = o?.referenceProduct?.referenceAttributes
          const tgt = o?.targetMerchant?.targetName || o?.targetMerchant?.targetHomepage
          const hasKeys = ref && typeof ref === 'object' && Object.keys(ref).length > 0
          const hasTarget = typeof tgt === 'string' && tgt.trim().length > 0
          if (hasKeys && hasTarget) {
            valid++
            Object.keys(ref).forEach(k => keySet.add(k))
          } else {
            invalid++
            if (invalidSamples.length < 5) {
              const reason = !hasKeys ? 'Missing referenceAttributes keys' : 'Missing targetName/homepage'
              invalidSamples.push(reason)
            }
          }
        }

        const sum: ValidateSummary = {
          sizeBytes: file.size,
          total: lines.length,
          valid,
          invalid,
          invalidSamples,
          uniqueRefKeys: Array.from(keySet).sort()
        }
        setSummary(sum)

        const history = loadHistory()
        const map: Record<string,string> = {}
        sum.uniqueRefKeys.forEach(k => map[k] = (typeof history[k] === 'string' && history[k]) ? history[k] : k)
        setMapping(map)
      } catch {
        setSummary({
          sizeBytes: file.size,
          total: 0,
          valid: 0,
          invalid: 1,
          invalidSamples: ['File parse error'],
          uniqueRefKeys: []
        })
        setMapping({})
      }
    })()
  }, [file])

  // Upload handler
  const doUpload = async () => {
    if (!file || !summary) return
    setBusy(true)
    try {
      const fd = new FormData()
      fd.set('name', name)
      fd.set('additional_prompt', prompt)
      fd.set('validate_images', String(validate))
      fd.set('worker_concurrency', String(10))  // fixed
      fd.set('file', file)
      fd.set('mapping', JSON.stringify(mapping))
      const result = await api.upload(fd)
      // Save mapping history (merge)
      const hist = loadHistory()
      const merged = { ...hist, ...mapping }
      saveHistory(merged)
      onUploaded({ job_id: result?.job_id, insertWhere: insertMode==='index' ? {mode:'index', index: insertIndex} : {mode: insertMode} })
      // reset
      setName(''); setPrompt(''); setValidate(false); setFile(null); setSummary(null); setMapping({})
      setInsertMode('top'); setInsertIndex(1)
    } catch (e:any) {
      throw e
    } finally {
      setBusy(false)
    }
  }

  return (
    <div className="card p-4">
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold">Create Task</h2>
      </div>

      {/* Name + Position + Workers (workers after position) */}
      <div className="grid gap-3 mt-3 sm:grid-cols-[1fr_auto_auto]">
        <div>
          <label className="block text-sm mb-1">Task name</label>
          <input className={clsx("input", nameTaken && "border-rose-400 focus:ring-rose-300")}
                 value={name} onChange={e=>setName(e.target.value)} />
          {nameTaken && <div className="text-xs text-rose-600 mt-1">A task with this name already exists.</div>}
        </div>

        <div>
          <label className="block text-sm mb-1">Label / Position</label>
          <div className="flex gap-2">
            <select className="input w-36" value={insertMode} onChange={e=>setInsertMode(e.target.value as any)}>
              <option value="top">Top</option>
              <option value="bottom">Bottom</option>
              <option value="index">Position #</option>
            </select>
            {insertMode==='index' && (
              <input
                className="input w-24"
                type="number"
                min={1}
                value={insertIndex}
                onChange={e=>setInsertIndex(parseInt(e.target.value||'1'))}
              />
            )}
          </div>
        </div>

        <div>
          <label className="block text-sm mb-1">Workers</label>
          <input className="input w-28" value={10} readOnly />
          <div className="text-xs text-slate-500 mt-1">Fixed to 10</div>
        </div>

        <div className="sm:col-span-3">
          <label className="block text-sm mb-1">Additional prompt (optional)</label>
          <textarea className="input h-24" value={prompt} onChange={e=>setPrompt(e.target.value)} />
        </div>
      </div>

      <div className="mt-3">
        <label className="inline-flex items-center gap-2">
          <input type="checkbox" className="checkbox" checked={validate} onChange={e=>setValidate(e.target.checked)} />
          <span>Validate Images</span>
        </label>
      </div>

      <div className="mt-3">
        <label className="block text-sm mb-1">Input file (.jsonl / .json / .txt / .jsonb)</label>
        <input className="input" type="file" accept=".jsonl,.json,.txt,.jsonb"
          onChange={e=>setFile(e.target.files?.[0] || null)} />
      </div>

      {/* Stats */}
      {summary && (
        <div className="mt-3 text-sm">
          <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
            <Stat label="File size" value={`${(summary.sizeBytes/1024).toFixed(1)} KB`} />
            <Stat label="Total rows" value={summary.total} />
            <Stat label="Valid" value={summary.valid} className="text-emerald-600 dark:text-emerald-400" />
            <Stat label="Invalid" value={summary.invalid} className="text-rose-600 dark:text-rose-400" />
          </div>
          {!!summary.invalidSamples.length && (
            <div className="text-xs text-rose-600 dark:text-rose-400 mt-1">
              Examples: {summary.invalidSamples.join(', ')}
            </div>
          )}
        </div>
      )}

      {/* Mapping preview (scrollable) */}
      {!!Object.keys(mapping).length && (
        <div className="mt-4">
          <h3 className="text-md font-semibold mb-2">Reference Key Mapping (preview)</h3>
          <div className="border rounded-lg">
            <div className="overflow-x-auto">
              <div className="max-h-[60vh] md:max-h-[420px] overflow-y-auto">
                <table className="w-full table min-w-[720px]">
                  <thead className="sticky top-0 z-10 bg-white dark:bg-slate-900">
                    <tr>
                      <th className="w-1/2">Key</th>
                      <th className="w-1/2">Mapped name</th>
                    </tr>
                  </thead>
                  <tbody>
                    {Object.entries(mapping).map(([k, v]) => (
                      <tr key={k}>
                        <td className="text-slate-500 align-top break-words max-w-[40ch]">{k}</td>
                        <td className="align-top">
                          <input
                            className="input w-full"
                            value={v}
                            onChange={(e) => setMapping((m) => ({ ...m, [k]: e.target.value || k }))}
                            onBlur={(e) => {
                              const hist = (() => { try { return JSON.parse(localStorage.getItem(LS_MAP_HISTORY) || '{}') } catch { return {} } })()
                              hist[k] = e.target.value || k
                              try { localStorage.setItem(LS_MAP_HISTORY, JSON.stringify(hist)) } catch {}
                            }}
                          />
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          <div className="text-xs text-slate-500 mt-1">Header is sticky; scroll to see all keys.</div>
        </div>
      )}

      <div className="mt-4">
        <button
          disabled={!canUpload}
          className={clsx(
            'btn',
            canUpload ? 'bg-brand-600 hover:bg-brand-700 text-white border-transparent' : 'opacity-50 cursor-not-allowed'
          )}
          onClick={async ()=>{
            try { await doUpload(); }
            catch(e:any){ pushToast({type:'error', title:'Upload failed', detail:String(e?.message || e)}) }
          }}>
          Upload & Create Task
        </button>
      </div>
    </div>
  )
}

function Stat({label, value, className}:{label:string; value:any; className?:string}) {
  return (
    <div className="p-2 rounded-lg border border-slate-200 dark:border-slate-800 bg-white/60 dark:bg-slate-900/60">
      <div className="text-xs text-slate-500">{label}</div>
      <div className={clsx("text-sm font-semibold", className)}>{value}</div>
    </div>
  )
}

/* ----------------------------- Draggable Row ----------------------------- */

function DraggableRow({id, hueClass, children}:{id:string; hueClass:string; children:(dragListeners:any)=>React.ReactNode}) {
  const {attributes, listeners, setNodeRef, transform, transition} = useSortable({id})
  const style = { transform: CSS.Transform.toString(transform), transition }
  return (
    <tr ref={setNodeRef} style={style} {...attributes} className={hueClass}>
      {children(listeners)}
    </tr>
  ) as any
}

/* ------------------------------- QueueTable ------------------------------ */

function QueueTable({
  jobs, isFetching,
  q, setQ,
  ownerFilter, setOwnerFilter,
  statusFilter, setStatusFilter,
  onReorder, onPause, onResume, onExport, onCancel, onDelete,
  pushToast,
}:{
  jobs: Job[];
  isFetching: boolean;
  q: string; setQ: React.Dispatch<React.SetStateAction<string>>;
  ownerFilter: string[];
  setOwnerFilter: React.Dispatch<React.SetStateAction<string[]>>;
  statusFilter: StatusKey[];
  setStatusFilter: React.Dispatch<React.SetStateAction<StatusKey[]>>;
  onReorder:(ids:string[])=>Promise<void>;
  onPause:(id:string)=>Promise<void>;
  onResume:(id:string)=>Promise<void>;
  onExport:(id:string)=>Promise<void>;
  onCancel:(id:string)=>Promise<void>;
  onDelete:(id:string)=>Promise<void>;
  pushToast: (t: Omit<Toast,'id'>) => void
}) {
  // pagination (persist page size)
  const initialPageSize = (() => {
    const saved = localStorage.getItem(LS_PAGE_SIZE)
    const n = saved ? parseInt(saved, 10) : 25
    return [10,25,50].includes(n) ? n : 25
  })()
  const [pageSize, setPageSize] = useState<number>(initialPageSize)
  const [page, setPage] = useState<number>(1)
  useEffect(()=>{ try { localStorage.setItem(LS_PAGE_SIZE, String(pageSize)) } catch {} }, [pageSize])
  // reset page when filters/search change
  useEffect(()=>setPage(1), [q, ownerFilter, statusFilter])

  const ownerOptions = useMemo(() => Array.from(new Set(jobs.map(j => j.owner))).sort(), [jobs])
  const filteredAll = useMemo(() => {
    const qn = q.trim().toLowerCase()
    return jobs.filter(j => {
      const ownerOk = ownerFilter.length === 0 || ownerFilter.includes(j.owner)
      const statusOk = statusFilter.length === 0 || statusFilter.includes(j.status as StatusKey)
      const qOk = !qn || [j.name, j.owner, j.status].some(v => v?.toLowerCase().includes(qn))
      return ownerOk && statusOk && qOk
    })
  }, [jobs, ownerFilter, statusFilter, q])

  // ordering state (full list), stable while dragging
  const [rows, setRows] = useState<Job[]>(filteredAll)
  const [dirty, setDirty] = useState(false)
  const lastServerOrderRef = useRef<string[]>(filteredAll.map(j=>j.id))

  useEffect(() => {
    if (!dirty) {
      setRows(filteredAll)
      lastServerOrderRef.current = filteredAll.map(j=>j.id)
    } else {
      const byId = new Map(filteredAll.map(j=>[j.id,j]))
      setRows(prev => prev
        .filter(j => byId.has(j.id))
        .map(j => ({...j, ...byId.get(j.id)!}))
        .concat(filteredAll.filter(j => !prev.some(p => p.id===j.id))))
    }
  }, [filteredAll, dirty])

  // compute current page slice from rows
  const pageCount = Math.max(1, Math.ceil(rows.length / pageSize))
  const safePage = Math.min(page, pageCount)
  const start = (safePage - 1) * pageSize
  const end = start + pageSize
  const paged = rows.slice(start, end)

  // progress: only poll running/pausing (scales better)
  const [progressMap, setProgressMap] = useState<Record<string, Progress>>({})
  useEffect(() => {
    let stop = false
    let cursor = 0
    const BATCH = 25
    const tick = async () => {
      const idsAll = rows.filter(r => ['running','pausing'].includes(r.status)).map(r=>r.id)
      if (!idsAll.length) { if (!stop) setProgressMap({}); return; }
      if (cursor >= idsAll.length) cursor = 0
      const slice = idsAll.slice(cursor, cursor + BATCH)
      cursor = (cursor + BATCH) % idsAll.length
      const entries = await Promise.all(slice.map(async id => {
        try { return [id, await api.jobProgress(id)] as const } catch { return [id, undefined] as const }
      }))
      if (!stop) {
        setProgressMap(prev => {
          const next = { ...prev }
          for (const [id, p] of entries) if (p) next[id] = p
          // prune anything no longer running/pausing
          for (const k of Object.keys(next)) {
            const row = rows.find(r => r.id===k)
            if (!row || !['running','pausing'].includes(row.status)) delete next[k]
          }
          return next
        })
      }
    }
    tick()
    const t = setInterval(tick, 5000)
    return () => { stop = true; clearInterval(t) }
  }, [rows])

  // DnD — only for current page items, but reorders in full "rows"
  const sensors = useSensors(useSensor(PointerSensor, { activationConstraint: { distance: 5 }}))
  const pageIds = paged.map(r => r.id)
  const onDragEnd = (event:any) => {
    const {active, over} = event;
    if (!over || active.id === over.id) return;
    const a = rows.findIndex(r => r.id === active.id)
    const b = rows.findIndex(r => r.id === over.id)
    if (a === -1 || b === -1) return
    const next = arrayMove(rows, a, b)
    setRows(next)
    setDirty(next.map(j=>j.id).join('|') !== lastServerOrderRef.current.join('|'))
  };

  // selection (page-scoped "select all")
  const [selectedIds, setSelectedIds] = useState<string[]>([])
  useEffect(()=>{ setSelectedIds([]) }, [ownerFilter, statusFilter, q, page, pageSize])
  const selected = new Set(selectedIds)
  const toggleAllInPage = (checked:boolean) => setSelectedIds(checked ? paged.map(r=>r.id) : [])
  const toggleOne = (id:string) => setSelectedIds(prev => prev.includes(id) ? prev.filter(x=>x!==id) : [...prev, id])

  // bulk actions
  const doBulk = async (kind:'pause'|'resume'|'cancel') => {
    const can = (j:Job) => kind==='pause' ? j.status==='running'
                  : kind==='resume' ? ['queued','paused','pausing'].includes(j.status)
                  : j.status==='running'
    const targets = rows.filter(r => selected.has(r.id) && can(r)).map(r=>r.id)
    if (!targets.length) return
    try {
      if (kind==='pause') await Promise.all(targets.map(onPause))
      else if (kind==='resume') await Promise.all(targets.map(onResume))
      else await Promise.all(targets.map(onCancel))
      const label = kind==='pause' ? 'Paused' : kind==='resume' ? 'Resumed' : 'Canceled'
      pushToast({type:'success', title:`${label} ${targets.length} job(s)`})
    } catch (e:any) {
      pushToast({type:'error', title:'Bulk action failed', detail:String(e?.message || e)})
    }
  }

  // ordering helpers
  const toTop = async (id:string) => {
    const nextOrderIds = [id, ...rows.filter(r => r.id !== id).map(r => r.id)]
    setRows((prev) => {
      const job = prev.find(j => j.id === id);
      if (!job) return prev;
      const others = prev.filter(j => j.id !== id);
      return [job, ...others];
    });
    try { await onReorder(nextOrderIds); pushToast({type:'success', title:'Moved to top'}) }
    catch(e:any){ pushToast({type:'error', title:'Failed to move to top', detail:String(e?.message || e)}) }
    setDirty(false)
    lastServerOrderRef.current = nextOrderIds
  }
  const moveUp = (id:string) => {
    const i = rows.findIndex(r=>r.id===id); if (i<=0) return
    const next = arrayMove(rows, i, i-1); setRows(next); setDirty(true)
  }
  const moveDown = (id:string) => {
    const i = rows.findIndex(r=>r.id===id); if (i===-1 || i===rows.length-1) return
    const next = arrayMove(rows, i, i+1); setRows(next); setDirty(true)
  }
  const saveOrder = async () => {
    const order = rows.map(r=>r.id)
    try { await onReorder(order); }
    finally {
      setDirty(false)
      lastServerOrderRef.current = order
    }
  }
  const orderChanged = rows.map(j=>j.id).join('|') !== lastServerOrderRef.current.join('|')

  // row coloring
  const rowHue = (s: StatusKey) => {
    switch (s) {
      case 'failed': return 'bg-rose-50 dark:bg-rose-950/30'
      case 'canceled': return 'bg-orange-50 dark:bg-orange-950/30'
      case 'completed': return 'bg-slate-50 dark:bg-slate-900/40'
      case 'running': case 'queued': case 'pausing': case 'paused':
        return 'bg-emerald-50/50 dark:bg-emerald-950/30'
      default: return ''
    }
  }

  const formatLocal = (iso?: string | null) => {
    if (!iso) return '–'
    const d = new Date(iso)
    const pad = (n:number) => (n<10?'0':'') + n
    const dd = pad(d.getDate())
    const mm = pad(d.getMonth()+1)
    const yyyy = d.getFullYear()
    const hh = pad(d.getHours())
    const mi = pad(d.getMinutes())
    return `${dd}/${mm}/${yyyy} ${hh}:${mi}`
  }

  /* ---------------------------- Responsive Toolbar ---------------------------- */
  const Chip = ({checked,label,onChange}:{checked:boolean;label:string;onChange:(v:boolean)=>void}) => (
    <label className={clsx(
      "px-2 py-1 rounded border text-sm cursor-pointer",
      checked ? "bg-brand-600 text-white border-transparent" : "bg-white dark:bg-slate-900 border-slate-300 dark:border-slate-700"
    )}>
      <input type="checkbox" className="hidden" checked={checked} onChange={e=>onChange(e.target.checked)} />
      {label}
    </label>
  )

  return (
    <div className="card p-3">
      {/* Row 1: Search + fetching state */}
      <div className="flex flex-wrap items-center justify-between gap-3">
        <div className="flex items-center gap-2 flex-1 min-w-[280px]">
          <input
            className="input w-full max-w-[380px]"
            placeholder="Search jobs (name, owner, status)…"
            value={q}
            onChange={e=>setQ(e.target.value)}
          />
          {q && <button className="text-sm underline text-slate-500" onClick={()=>setQ('')}>Clear</button>}
        </div>
        <span className="text-sm text-slate-500 shrink-0">{isFetching ? 'Refreshing…' : 'Up to date'}</span>
      </div>

      {/* Row 2: Owners + Statuses (wrap) */}
      <div className="mt-3 grid gap-3 md:grid-cols-2">
        <div className="flex items-center gap-2 flex-wrap">
          <span className="text-sm">Owners:</span>
          <div className="flex flex-wrap gap-2">
            {ownerOptions.map(o => (
              <Chip
                key={o}
                checked={ownerFilter.includes(o)}
                label={o}
                onChange={(on)=> setOwnerFilter((prev: string[]) => on ? [...prev, o] : prev.filter((x: string)=>x!==o))}
              />
            ))}
            <button className="text-xs underline text-slate-500" onClick={()=>setOwnerFilter([])}>Clear</button>
          </div>
        </div>

        <div className="flex items-center gap-2 flex-wrap">
          <span className="text-sm">Statuses:</span>
          <div className="flex flex-wrap gap-2">
            {STATUS_LIST.map(s => (
              <Chip
                key={s}
                checked={statusFilter.includes(s)}
                label={s}
                onChange={(on)=> setStatusFilter((prev: StatusKey[]) => on ? [...prev, s] : prev.filter((x: StatusKey)=>x!==s))}
              />
            ))}
            <button className="text-xs underline text-slate-500" onClick={()=>setStatusFilter([])}>Clear</button>
          </div>
        </div>
      </div>

      {/* Row 3: Bulk + Save + Pagination controls */}
      <div className="mt-3 flex flex-wrap items-center justify-between gap-3">
        <div className="flex items-center gap-2">
          <button className="inline-flex items-center gap-1 px-2 py-1 rounded border text-sm bg-amber-600 text-white border-transparent hover:bg-amber-700"
                  onClick={()=>doBulk('pause')}>
            <Pause size={14}/> Pause
          </button>
          <button className="inline-flex items-center gap-1 px-2 py-1 rounded border text-sm bg-emerald-600 text-white border-transparent hover:bg-emerald-700"
                  onClick={()=>doBulk('resume')}>
            <Play size={14}/> Resume
          </button>
          <button className="inline-flex items-center gap-1 px-2 py-1 rounded border text-sm bg-rose-600 text-white border-transparent hover:bg-rose-700"
                  onClick={()=>doBulk('cancel')}>
            <XCircle size={14}/> Cancel
          </button>
          <button
            className={clsx(
              'inline-flex items-center gap-1 px-2 py-1 rounded border text-sm',
              orderChanged ? 'bg-brand-600 text-white border-transparent hover:bg-brand-700' : 'opacity-50 cursor-not-allowed bg-slate-200 dark:bg-slate-800 text-slate-500 border-slate-300 dark:border-slate-700'
            )}
            onClick={orderChanged ? saveOrder : undefined}
          >
            Save Order
          </button>
        </div>

        <div className="flex items-center gap-3">
          <div className="text-sm text-slate-500">
            Page {safePage} / {pageCount} — showing {rows.length ? `${start+1}-${Math.min(end, rows.length)}` : '0'} of {rows.length}
          </div>
          <div className="flex items-center gap-2">
            <button className="btn" disabled={safePage<=1} onClick={()=>setPage(p=>Math.max(1, p-1))}>Prev</button>
            <button className="btn" disabled={safePage>=pageCount} onClick={()=>setPage(p=>Math.min(pageCount, p+1))}>Next</button>
            <select className="input" value={pageSize} onChange={e=>setPageSize(parseInt(e.target.value||'25',10))}>
              {[10,25,50].map(n => <option key={n} value={n}>{n}/page</option>)}
            </select>
          </div>
        </div>
      </div>

      {/* Table */}
      <div className="overflow-x-auto mt-3">
        <table className="w-full table">
          <colgroup>
            <col className="w-8" /> {/* checkbox */}
            <col className="w-20" />
            <col className="w-[260px] sm:w-[320px]" />
            <col className="w-36" /> {/* Owner */}
            <col className="w-40" /> {/* Created */}
            <col className="w-28" /> {/* Status */}
            <col />                  {/* Progress */}
            <col className="w-12" /> {/* Actions menu */}
          </colgroup>
          <thead>
            <tr>
              <th>
                <input
                  type="checkbox"
                  className="checkbox"
                  checked={paged.length>0 && paged.every(r => selected.has(r.id))}
                  onChange={e => toggleAllInPage(e.target.checked)}
                  aria-label="Select page"
                />
              </th>
              <th>#</th><th>Name</th><th>Owner</th><th>Created</th><th>Status</th><th>Progress</th><th></th>
            </tr>
          </thead>

          <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={onDragEnd}>
            <SortableContext items={pageIds} strategy={verticalListSortingStrategy}>
              <tbody>
                {paged.map((j, idxOnPage) => {
                  const idxGlobal = start + idxOnPage
                  const p = progressMap[j.id]
                  const pct = p?.total
                    ? Math.floor((p.done / p.total) * 100)
                    : (j.total_rows ? Math.floor((j.processed_rows/j.total_rows)*100) : 0)

                  const hue = rowHue(j.status as StatusKey)
                  const isSelected = selected.has(j.id)

                  return (
                    <DraggableRow key={j.id} id={j.id} hueClass={clsx(hue, isSelected && 'ring-2 ring-brand-600/50')}>
                      {(dragListeners:any) => (
                        <>
                          <td className="align-top">
                            <input
                              type="checkbox"
                              className="checkbox"
                              checked={isSelected}
                              onChange={() => toggleOne(j.id)}
                              aria-label={`Select ${j.name}`}
                            />
                          </td>

                          <td className="align-top">
                            <div className="flex items-center gap-2">
                              <button
                                className="inline-flex items-center justify-center h-7 w-7 rounded border border-slate-300 dark:border-slate-700 text-slate-600 dark:text-slate-300 bg-white dark:bg-slate-900"
                                title="Drag to reorder" {...dragListeners}
                              >≡</button>
                              <span className="text-slate-500">{idxGlobal+1}</span>
                            </div>
                          </td>

                          <td className="font-medium truncate whitespace-nowrap align-top" title={j.name}>
                            {j.name}
                          </td>

                          <td className="text-slate-500 truncate align-top">{j.owner}</td>
                          <td className="text-slate-500 align-top">{formatLocal(j.created_at)}</td>
                          <td className="align-top"><span className="px-2 py-0.5 rounded-full border text-xs">{j.status}</span></td>

                          <td className="align-top">
                            <div className="w-full">
                              <div className="h-2 bg-slate-200 dark:bg-slate-800 rounded-full overflow-hidden">
                                <div className="h-full bg-emerald-600" style={{width: `${pct}%`}}/>
                              </div>
                              <div className="text-xs text-slate-500 mt-1">
                                {p ? `${p.done}/${p.total}` : `${j.processed_rows}/${j.total_rows}`} ({pct}%)
                              </div>
                            </div>
                          </td>

                          <td className="align-top">
                            <RowActions
                              job={j}
                              onResume={()=>onResume(j.id)}
                              onPause={()=>onPause(j.id)}
                              onCancel={()=>onCancel(j.id)}
                              onDelete={()=>onDelete(j.id)}
                              onExport={()=>onExport(j.id)}
                              onTop={()=>toTop(j.id)}
                              onUp={()=>moveUp(j.id)}
                              onDown={()=>moveDown(j.id)}
                            />
                          </td>
                        </>
                      )}
                    </DraggableRow>
                  )
                })}

                {!paged.length && (
                  <tr><td colSpan={8} className="text-center py-6 text-slate-500">No jobs</td></tr>
                )}
              </tbody>
            </SortableContext>
          </DndContext>
        </table>
      </div>
    </div>
  )
}

/* ------------------------------ RowActions ------------------------------ */

function RowActions({
  job, onResume, onPause, onCancel, onDelete, onExport, onTop, onUp, onDown
}:{
  job: Job
  onResume: ()=>void
  onPause: ()=>void
  onCancel: ()=>void
  onDelete: ()=>void
  onExport: ()=>void
  onTop: ()=>void
  onUp: ()=>void
  onDown: ()=>void
}) {
  const [open, setOpen] = useState(false)
  return (
    <div className="relative">
      <button
        className="inline-flex h-8 w-8 items-center justify-center rounded border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900"
        onClick={()=>setOpen(o=>!o)}
        aria-label="Actions"
      >
        <MoreVertical size={16}/>
      </button>
      {open && (
        <div className="absolute right-0 mt-1 w-44 rounded-md border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900 shadow-lg z-20">
          <ul className="py-1 text-sm">
            <li><button className="menu-item" onClick={()=>{ setOpen(false); onTop() }}>
              <ChevronsUp size={14} className="mr-2"/> To top
            </button></li>

            {job.status==='running'
              ? <li><button className="menu-item" onClick={()=>{ setOpen(false); onPause() }}>
                  <Pause size={14} className="mr-2"/> Pause
                </button></li>
              : <li><button disabled={!['queued','paused','pausing'].includes(job.status)} className="menu-item disabled:opacity-50" onClick={()=>{ setOpen(false); onResume() }}>
                  <Play size={14} className="mr-2"/> Resume
                </button></li>
            }

            <li><button disabled={job.status!=='running'} className="menu-item disabled:opacity-50" onClick={()=>{ setOpen(false); onCancel() }}>
              <XCircle size={14} className="mr-2"/> Cancel
            </button></li>

            <li><button className="menu-item" onClick={()=>{ setOpen(false); onExport() }}>
              <FileDown size={14} className="mr-2"/> Export
            </button></li>

            <li><button disabled={job.status==='running'||job.status==='pausing'} className="menu-item text-rose-600 disabled:opacity-50" onClick={()=>{ setOpen(false); onDelete() }}>
              <Trash2 size={14} className="mr-2"/> Delete
            </button></li>

            {/* hidden UI brought into menu as requested */}
            <li><hr className="my-1 border-slate-200 dark:border-slate-700"/></li>
            <li><button className="menu-item" onClick={()=>{ setOpen(false); onUp() }}>Move up</button></li>
            <li><button className="menu-item" onClick={()=>{ setOpen(false); onDown() }}>Move down</button></li>
          </ul>
        </div>
      )}
    </div>
  )
}

/* ----------------------------- tiny CSS helpers ----------------------------- */
/* If you don't already have these utility classes in your Tailwind layer, add: 
   .btn, .input, .checkbox, .card, .table, .shadow-soft, .menu-item
   (you had them earlier; menu-item is new) */

/* Example (keep in your global CSS):
.menu-item { @apply w-full px-3 py-1.5 text-left hover:bg-slate-100 dark:hover:bg-slate-800 flex items-center; }
*/

